package org.oldskooler.entity4j.mapping;

import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Objects;
import java.util.function.Consumer;

/** Fluent DSL scoped to a single DbContext instance (called from onModelCreating). */
public final class ModelBuilder {
    private final MappingRegistry registry;
    public ModelBuilder(MappingRegistry registry) { this.registry = registry; }

    public <T> EntityBuilder<T> entity(Class<T> type) { return new EntityBuilder<>(registry, type); }

    /** Column options exposed to users: nullable, type, precision, scale, and column name override. */
    public interface ColumnOptions {
        ColumnOptions name(String columnName);     // override the DB column name
        ColumnOptions nullable(boolean isNullable);
        ColumnOptions type(String sqlType);        // e.g. "VARCHAR", "DECIMAL", "JSONB"
        ColumnOptions precision(int p);            // for DECIMAL/NUMERIC
        ColumnOptions scale(int s);                // for DECIMAL/NUMERIC
        ColumnMeta toMeta();
        ColumnOptions length(int i);
        ColumnOptions value(String s);
    }

    static final class ColumnBuilder implements ColumnOptions {
        final String property;
        String name;
        boolean nullable = true;                   // default: nullable
        String type = "";
        int precision = 0;
        int scale = 0;
        int length = -1;
        String value = "";

        ColumnBuilder(String property) {
            this.property = property;
            this.name = property;
        }
        @Override public ColumnOptions name(String n) { this.name = n; return this; }
        @Override public ColumnOptions nullable(boolean b) { this.nullable = b; return this; }
        @Override public ColumnOptions type(String t) { this.type = t; return this; }
        @Override public ColumnOptions precision(int p) { this.precision = p; return this; }
        @Override public ColumnOptions scale(int s) { this.scale = s; return this; }
        @Override public ColumnOptions value(String s) { this.value = s; return this; }

        @Override
        public ColumnMeta toMeta() {
            return new ColumnMeta(property, name, nullable, type, value, precision, scale, length);
        }

        @Override
        public ColumnOptions length(int i) {
            length = i; return this;
        }


    }

    public static final class EntityBuilder<T> {
        private final MappingRegistry reg;
        private final Class<T> type;

        private String table;
        private final Map<String, PrimaryKey> keys;

        private final LinkedHashMap<String, String> propToColumn = new LinkedHashMap<>();
        private final LinkedHashMap<String, ColumnMeta> columnMeta = new LinkedHashMap<>();
        private final java.util.Set<String> ignored = new java.util.LinkedHashSet<>();

        EntityBuilder(MappingRegistry reg, Class<T> type) {
            this.reg = reg;
            this.type = type;
            this.keys = new HashMap<>();

        }

        /** Target table name. */
        public EntityBuilder<T> toTable(String table) { this.table = table; return this; }

        /** Primary key property. */
        public EntityBuilder<T> hasId(String property) {
            return hasId(property, property, true);
        }

        public EntityBuilder<T> hasId(String property, String column) {
            return hasId(property, column, true);
        }

        public EntityBuilder<T> hasId(String property, String column, boolean autoGenerated) {
            if (autoGenerated && !this.keys.isEmpty()) {
                throw new IllegalArgumentException("auto=true not supported when multiple key columns are declared for type: " + this.type.getName());
            }

            if (property != null) {
                this.keys.put(property, new PrimaryKey(property, column, autoGenerated));
                propToColumn.put(property, column);
                // keep id non-nullable by default
                columnMeta.put(column, new ColumnBuilder(property).name(column).nullable(false).toMeta());
            }

            return this;
        }

        public EntityBuilder<T> hasKey(String property) {
            return hasId(property, property, false);
        }

        public EntityBuilder<T> hasKey(String property, String column) {
            return hasId(property, column, false);
        }

        /** Map property to a differently named column (no extra options). */
        public EntityBuilder<T> map(String property, String column) {
            propToColumn.put(property, column);
            columnMeta.putIfAbsent(column, new ColumnBuilder(property).name(column).toMeta());
            return this;
        }

        /** Map property to a same-named column (no extra options). */
        public EntityBuilder<T> mapSame(String property) {
            return map(property, property);
        }

        /** NEW: Full column specification (nullable, type, precision/scale, name override). */
        public EntityBuilder<T> column(String property, Consumer<ColumnOptions> config) {
            ColumnBuilder cb = new ColumnBuilder(property);
            config.accept(cb);
            propToColumn.put(property, cb.name);
            columnMeta.put(cb.name, cb.toMeta());
            return this;
        }

        /** Exclude a property (equivalent of @NotMapped). */
        public EntityBuilder<T> ignore(String property) {
            ignored.add(property);
            propToColumn.remove(property);
            columnMeta.remove(property);
            return this;
        }

        /** Finalize this entity mapping and return to the root builder. */
        public ModelBuilder done() {
            Objects.requireNonNull(table, "table");

            for (Map.Entry<String, PrimaryKey> key : this.keys.entrySet()) {
                PrimaryKey data = key.getValue();
                propToColumn.putIfAbsent(data.property, data.column);
                columnMeta.putIfAbsent(data.property, new ColumnBuilder(data.property).name(data.column).nullable(false).toMeta());
            }

            for (String p : ignored) { propToColumn.remove(p); columnMeta.remove(p); }

            reg.register(new EntityMapping<>(type, table, keys, propToColumn, columnMeta));
            return new ModelBuilder(reg);
        }
    }
}
